rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // USERS
    // ============================================
    match /users/{userId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;

      // User subcollections — owner-only read; writes handled by Cloud Functions
      match /notifications/{notificationId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow update: if request.auth != null && request.auth.uid == userId
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
        allow create, delete: if false; // Cloud Functions only
      }

      match /transactions/{transactionId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if false; // Cloud Functions only
      }

      match /xpHistory/{xpId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow update, delete: if false; // Cloud Functions only
      }

      // Streak subcollection — owner read/write
      match /streak/{streakId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Battle Pass subcollection — owner read/write
      match /battlePass/{seasonId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Reward history — owner read and create (claimed from battle pass)
      match /rewardHistory/{rewardId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow update, delete: if false;
      }

      // Pending rewards — owner read and create (physical reward claims)
      match /pendingRewards/{rewardId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow update, delete: if false;
      }

      // Challenges subcollection under user (if used)
      match /challenges/{challengeId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if false;
      }

      // Subscription subcollection — owner read/write
      match /subscription/{subscriptionId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Friends subcollection — owner can read; writes handled by service
      match /friends/{friendId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow delete: if request.auth != null && request.auth.uid == userId;
        allow update: if false;
      }
    }

    // ============================================
    // FRIEND REQUESTS
    // ============================================
    match /friendRequests/{requestId} {
      allow read: if request.auth != null
                  && (resource.data.senderId == request.auth.uid
                      || resource.data.receiverId == request.auth.uid);
      allow create: if request.auth != null
                    && request.resource.data.senderId == request.auth.uid
                    && request.resource.data.keys().hasAll(['senderId', 'receiverId', 'status', 'senderName', 'receiverName'])
                    && request.resource.data.status == 'pending';
      allow update: if request.auth != null
                    && resource.data.receiverId == request.auth.uid
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']);
      allow delete: if false;
    }

    // ============================================
    // WALLETS
    // ============================================
    match /wallets/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
      // Only allow client-side balance decreases (stakes, withdrawals).
      // Balance increases (winnings, refunds, deposits) MUST go through Cloud Functions.
      allow update: if request.auth != null && request.auth.uid == userId
                    && request.resource.data.balance <= resource.data.balance;

      // Wallet transactions — owner can read; client can create stake debits
      match /transactions/{transactionId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId;
        allow update, delete: if false;
      }
    }

    // ============================================
    // CHALLENGES
    // ============================================
    match /challenges/{challengeId} {
      allow read: if request.auth != null
                  && request.auth.uid in resource.data.participantIds;
      allow create: if request.auth != null
                    && request.auth.uid in request.resource.data.participantIds
                    && request.resource.data.keys().hasAll(['creatorId', 'status', 'stakeAmount', 'goalType', 'participantIds'])
                    && request.resource.data.creatorId == request.auth.uid;
      // Participants can update only safe fields (progress, sync data, status transitions)
      allow update: if request.auth != null
                    && request.auth.uid in resource.data.participantIds
                    && !request.resource.data.diff(resource.data).affectedKeys()
                        .hasAny(['stakeAmount', 'totalPot', 'prizeAmount', 'creatorId', 'participantIds']);

      match /dailySteps/{dayId} {
        allow read, write: if request.auth != null
                          && request.auth.uid in get(/databases/$(database)/documents/challenges/$(challengeId)).data.participantIds;
      }

      match /dailyActivity/{dayId} {
        allow read, write: if request.auth != null
                          && request.auth.uid in get(/databases/$(database)/documents/challenges/$(challengeId)).data.participantIds;
      }
    }

    // ============================================
    // NOTIFICATIONS (top-level — used by firebase_service.dart)
    // ============================================
    match /notifications/{notificationId} {
      allow read: if request.auth != null
                  && resource.data.userId == request.auth.uid;
      allow update: if request.auth != null
                    && resource.data.userId == request.auth.uid
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
      // Allow authenticated users to create notifications (e.g., challenge invites).
      // Must include senderId matching the authenticated user to prevent impersonation.
      // Type must be one of the allowed client-generated types.
      allow create: if request.auth != null
                    && request.resource.data.keys().hasAll(['userId', 'type', 'title', 'body', 'read', 'senderId'])
                    && request.resource.data.read == false
                    && request.resource.data.senderId == request.auth.uid
                    && request.resource.data.userId != request.auth.uid
                    && request.resource.data.type in ['challenge_invite', 'challenge_accepted', 'challenge_declined'];
      allow delete: if false;
    }

    // ============================================
    // SEASONS (read-only for users)
    // ============================================
    match /seasons/{seasonId} {
      allow read: if request.auth != null;
      allow write: if false; // Admin / Cloud Functions only
    }

    // ============================================
    // ACTIVITY FEED (authenticated read, Cloud Functions write)
    // ============================================
    match /activityFeed/{entryId} {
      allow read: if request.auth != null;
      // Require userId to match the authenticated user to prevent spoofing
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }

    // ============================================
    // SPONSORED CHALLENGES
    // ============================================
    match /sponsoredChallenges/{challengeId} {
      allow read: if request.auth != null;
      allow create, delete: if false; // Admin only
      // Allow incrementing currentParticipants (join) and views (analytics)
      allow update: if request.auth != null
                    && request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['currentParticipants', 'views']);

      // Participants subcollection — authenticated users can join
      match /participants/{participantId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null && request.auth.uid == participantId;
        allow update, delete: if false;
      }
    }

    // ============================================
    // LEADERBOARD (public read)
    // ============================================
    match /leaderboard/{userId} {
      allow read: if request.auth != null;
      allow write: if false; // Cloud Functions only
    }

    // ============================================
    // ADMIN NOTIFICATIONS
    // ============================================
    match /adminNotifications/{notificationId} {
      allow read, write: if false; // Cloud Functions only
    }

    // ============================================
    // WAITLIST (unauthenticated create with validation)
    // ============================================
    match /waitlist/{entryId} {
      allow create: if request.resource.data.keys().hasAll(['name', 'contact'])
                    && request.resource.data.name is string
                    && request.resource.data.contact is string
                    && request.resource.data.name.size() > 0
                    && request.resource.data.name.size() <= 100
                    && request.resource.data.contact.size() > 0
                    && request.resource.data.contact.size() <= 200;
      allow read, update, delete: if false;
    }
  }
}
